#include <vector>
#include <stdexcept>
#include "matrix.hpp"
#include "GivensQR.hpp"
/*
Finds the coefficients of a polynomial p(x) of degree n that fits the data,
p(x(i)) to y(i), in a least squares sense. The result p is a row vector of
length n+1 containing the polynomial coefficients in incremental powers.

param:
oX				x axis values
oY				y axis values
nDegree			polynomial degree including the constant

return:
coefficients of a polynomial starting at the constant coefficient and
ending with the coefficient of power to nDegree. C++0x-compatible
compilers make returning locally created vectors very efficient.

*/
template<typename T>
std::vector<T> polyfitqr(const std::vector<T>& oX, const std::vector<T>& oY, int nDegree) {
  if (oX.size() != oY.size())
    throw std::invalid_argument("X and Y vector sizes do not match");

  // more intuative this way
  nDegree++;

  size_t nCount = oX.size();
  mathalgo::matrix<T> oXMatrix(nCount, nDegree);
  mathalgo::matrix<T> oYMatrix(nCount, 1);

  // copy y matrix
  for (size_t i = 0; i < nCount; i++) {
    oYMatrix(i, 0) = oY[i];
  }

  // create the X matrix
  for (size_t nRow = 0; nRow < nCount; nRow++) {
    T nVal = 1.0f;
    for (int nCol = 0; nCol < nDegree; nCol++) {
      oXMatrix(nRow, nCol) = nVal;
      nVal *= oX[nRow];
    }
  }

  // transpose X matrix
  mathalgo::matrix<T> oXtMatrix(oXMatrix.transpose());
  // multiply transposed X matrix with X matrix
  mathalgo::matrix<T> oXtXMatrix(oXtMatrix * oXMatrix);
  // multiply transposed X matrix with Y matrix
  mathalgo::matrix<T> oXtYMatrix(oXtMatrix * oYMatrix);

  mathalgo::Givens<T> oGivens;
  oGivens.Decompose(oXtXMatrix);
  mathalgo::matrix<T> oCoeff = oGivens.Solve(oXtYMatrix);
  // copy the result to coeff
  return oCoeff.data();
}

/*
Calculates the value of a polynomial of degree n evaluated at x. The input
argument pCoeff is a vector of length n+1 whose elements are the coefficients
in incremental powers of the polynomial to be evaluated.

param:
oCoeff			polynomial coefficients generated by polyfit() function
oX				x axis values

return:
Fitted Y values. C++0x-compatible compilers make returning locally
created vectors very efficient.
*/
template<typename T>
std::vector<T> polyvalqr(const std::vector<T>& oCoeff, const std::vector<T>& oX) {
  size_t nCount = oX.size();
  size_t nDegree = oCoeff.size();
  std::vector<T>	oY(nCount);

  for (size_t i = 0; i < nCount; i++) {
    T nY = 0;
    T nXT = 1;
    T nX = oX[i];
    for (size_t j = 0; j < nDegree; j++) {
      // multiply current x by a coefficient
      nY += oCoeff[j] * nXT;
      // power up the X
      nXT *= nX;
    }
    oY[i] = nY;
  }

  return oY;
}

template<typename T>
mathalgo::matrix<T> combineXY(std::vector<T>& oX, std::vector<T>& oY) {
  size_t nCount = oX.size();
  size_t nCols = 3 * 2; // 3 unknowns in 2 dimensions
  mathalgo::matrix<T> oXYMatrix(nCount, nCols);
  
  // normalize x and y matrix
  for (size_t i = 1; i < nCount; i++) {
    oX[i] = oX[i] - oX[0];
    oY[i] = oY[i] - oY[0];
  }
  oX[0] = 0;
  oY[0] = 0;

  // create the XY matrix
  for (size_t nRow = 0; nRow < nCount; nRow++) {
    oXYMatrix(nRow, 0) = 1;
    oXYMatrix(nRow, 1) = oX[nRow];
    oXYMatrix(nRow, 2) = oY[nRow];
    oXYMatrix(nRow, 3) = oX[nRow] * oY[nRow];
    oXYMatrix(nRow, 4) = std::pow(oX[nRow], 2);
    oXYMatrix(nRow, 5) = std::pow(oY[nRow], 2);
  }
  return oXYMatrix;
}

// 3D plane fitting
template<typename T>
std::vector<T> polyfit3d(std::vector<T>& oX, std::vector<T>& oY, std::vector<T>& oZ, std::vector<T>& calculated) {
  if (oX.size() != oY.size() || oX.size() != oZ.size())
    throw std::invalid_argument("X and Y or X and Z vector sizes do not match");

  size_t nCount = oX.size();
  mathalgo::matrix<T> A(combineXY(oX, oY));
  mathalgo::matrix<T> X(nCount, 1);

  // copy z matrix
  for (size_t i = 0; i < nCount; i++) {
    X(i, 0) = oZ[i];
  }

  // Y=(AT*A)-1*AT*X
  // transpose X matrix
  mathalgo::matrix<T> AT(A.transpose());
  // multiply transposed X matrix with X matrix
  mathalgo::matrix<T> ATA(AT * A);
  // multiply transposed X matrix with Y matrix
  mathalgo::matrix<T> ATX(AT * X);

  mathalgo::Givens<T> oGivens;
  oGivens.Decompose(ATA);
  mathalgo::matrix<T> Y = oGivens.Solve(ATX);

  mathalgo::matrix<T> AY(A * Y.transpose());

  calculated = AY.data();
  // copy the result to coeff
  return Y.data();
}

template<typename T>
std::vector<T> polyval3d(std::vector<T>& x, std::vector<T>& y, std::vector<T>& coeff) {
  mathalgo::matrix<double> A = combineXY(x, y);
  mathalgo::matrix<double> Y(coeff.size(), 1);
  // build coeff matrix
  for (size_t i = 0; i < coeff.size(); i++) {
    Y(i, 0) = coeff[i];
  }
  mathalgo::matrix<T> AY(A * Y);
  return AY.data();
}